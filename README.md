## 读请求优化: 
leader处理read-only请求是没必要向大多数节点征求共识的, 会造成额外的网络通信和日志落盘开销，但需要保证两点: leader确实是当前最新的, 此时leader中共识完毕的日志必须已经全部送入状态机。

**方案**：对于第一点, 可以让leader维护一个安全租期(超时时间由base+random区间组成，安全租期即为base，如果考虑时钟偏移，可以 为安全期添加一个“惩罚”因子)。对于第二点, 需要在leader当选时立即发布一个空日志, 通过空日志的index值来判断状态机是否更新到最新 的状态(leader无法主动提交非自己任期内的日志需要新日志进行捎带，论文中figure8部分进行了详细说明)。   
## 预选举优化：
在网络分区情况下，少数机器会一直进行选举同时增加自身Term值，当网络分区恢复时这部分机器会由于自身的Term值高于 leader导致正常工作的leader进行重新选举，这是没有必要的。   

**方案**：在正式选举之前先进行一轮预选举，此时发起的选举Term值不会增加，当预选举成功时，增加Term值发起真正的选举。   
## 分片优化：
raft为了可理解性使用了单leader机制，但所有的请求都由leader处理很容易使得leader成为性能瓶颈。   

**方案**：将数据集分割成互不相交的子集，每个子集由raft集群进行管理，通过configuration服务器将客户端的请求导向不同的raft集群。 该方案使得集群容错能力和性能可以随着机器的增加而增加。在此基础上使用哈希环算法可以使得分片能够动态扩展。  
